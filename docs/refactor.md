# リファクタリング計画書

## 1. 目的

本ドキュメントは、MochiRAGアプリケーションのソースコードについて、将来の機能追加やメンテナンスを容易にするためのリファクタリング計画を提案するものです。主な目的は、**保守性、テスト容易性、および拡張性**の向上です。

---

## 2. 提案事項

### 提案1: 依存性注入 (Dependency Injection) の全面的な導入

- **優先度:** **高**
- **対象領域:** `core`および`backend`の主要コンポーネント

#### 現状の課題

現在、`llm_manager`, `retriever_manager`, `ingestion_service` といった主要なサービスがグローバルなシングルトンインスタンスとして実装・利用されています。これにより、コンポーネント間の依存関係が暗黙的になり、特にユニットテスト作成時に `unittest.mock.monkeypatch` を多用する必要が生じています。これはテストコードを複雑にし、可読性を低下させる一因です。

#### 提案内容

アプリケーションの起動時に依存関係を一元的に構築し、各コンポーネントにはコンストラクタや関数の引数を通じて、必要な依存オブジェクトを明示的に渡す「依存性注入（DI）」のパターンを導入します。

**具体的な手順:**
1.  FastAPIが提供するDI機構 (`Depends`) を最大限に活用します。各Managerクラスを、リクエストごとにインスタンス化されるか、あるいはアプリケーションのライフサイクルで一度だけインスタンス化される依存オブジェクトとして定義し直します。
2.  `RAGChainService` や各 `RetrieverStrategy` などのサービスクラスは、コンストラクタ (`__init__`) で `LLMManager` や `VectorStoreManager` のインスタンスを受け取るように変更します。
3.  FastAPIのエンドポイント関数内では、`Depends` を使って、必要なサービスを取得します。

#### 期待される効果

- **テスト容易性の向上:** `monkeypatch` が不要になり、テスト対象のコンポーネントに直接モックオブジェクトを注入できるため、ユニットテストが劇的にシンプルかつ堅牢になります。
- **保守性の向上:** クラスや関数が必要とする依存関係がシグネチャから明確になり、コードの可読性と保守性が向上します。

---

### 提案2: 設定管理 (`ConfigManager`) の責務の明確化

- **優先度:** 中
- **対象領域:** `core/config_manager.py` および設定を利用する各クラス

#### 現状の課題

`config/strategies.yaml` のパースロジックが、`ConfigManager` だけでなく、`IngestionService` の `__init__` メソッドなど、設定を利用する側のクラスにも散在しています。これにより、設定の構造が変更された際の影響範囲が広くなっています。

#### 提案内容

設定ファイルの読み込みと解釈に関するロジックを `ConfigManager` に完全に集約します。`ConfigManager` は、各設定セクションに対応する厳密に型付けされたPydanticモデル（例: `LLMConfig`, `RetrieverConfig`）を返し、利用側のクラスはこれらの設定オブジェクトを受け取るようにします。

#### 期待される効果

- **設定ロジックの集約:** 設定に関する責任が一箇所にまとまり、コードの見通しが良くなります。
- **型安全性:** Pydanticモデルによる厳密な型チェックにより、設定ミスに起因する実行時エラーを減らします。

---

### 提案3: `RetrieverManager` と `VectorStoreManager` の抽象化の徹底

- **優先度:** 中
- **対象領域:** `core/retriever_manager.py`, `core/vector_store_manager.py`

#### 現状の課題

`BasicRetrieverStrategy` などの一部の戦略クラスが、`vector_store.as_retriever()` のように、`VectorStoreManager` から返されるオブジェクトがChromaDBのラッパーであることを依然として意識しています。

#### 提案内容

`VectorStoreManager` が、`as_retriever()` の呼び出しも含めて、リトリーバーを生成する責務を持つように変更します。例えば、`vector_store_manager.get_retriever(collection_name, filter)` のようなメソッドを公開し、戦略クラスはこれを呼び出すだけにします。これにより、戦略クラスはベクトルストアの具体的な実装（ChromaDBであること）から完全に独立します。

#### 期待される効果

- **抽象度の向上:** 戦略クラスとインフラストラクチャ層（ベクトルストア）の結合度が下がり、将来的にChromaDBを別のベクトルストアに置き換えることがより容易になります。

---

### 提案4: フロントエンド (`api_client.py`) の責務分離

- **優先度:** 低
- **対象領域:** `frontend/api_client.py` とUIを構成する各ファイル

#### 現状の課題

`ApiClient` クラスが、HTTPリクエストの送信ロジックと、`st.error` や `st.success` といったStreamlitのUI更新ロジックを両方含んでいます。

#### 提案内容

`ApiClient` の責務を、HTTPリクエストの実行と、成功時のデータ返却または失敗時の例外送出のみに限定します。UIの更新（成功メッセージやエラーメッセージの表示）は、`ui_chat.py` などのUIを構成する側のコードが、`ApiClient` を呼び出し、その結果（または例外）をハンドリングして行うように責務を分離します。

#### 期待される効果

- **関心の分離:** API通信ロジックとUIロジックが明確に分離され、それぞれのテストが容易になります。
- **再利用性の向上:** `ApiClient` がUIフレームワークに依存しなくなるため、将来的にUIを別の技術に置き換える際にも再利用しやすくなります。
